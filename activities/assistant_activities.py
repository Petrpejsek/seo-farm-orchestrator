import json
import logging
import os
from datetime import datetime
from typing import Dict, Any
import requests
from openai import OpenAI
from temporalio import activity

logger = logging.getLogger(__name__)

def get_api_key(service: str) -> str:
    """
    Naƒçte API kl√≠ƒç pro danou slu≈æbu z backend API nebo environment variables jako fallback.
    
    Args:
        service: N√°zev slu≈æby (nap≈ô. "openai")
        
    Returns:
        API kl√≠ƒç
        
    Raises:
        Exception: Pokud API kl√≠ƒç nen√≠ nalezen
    """
    try:
        # Pokus o naƒçten√≠ z backend API
        backend_url = os.getenv("API_BASE_URL", "http://localhost:8000")
        response = requests.get(f"{backend_url}/api-keys/{service}", timeout=5)
        
        if response.status_code == 200:
            data = response.json()
            api_key = data.get("api_key")
            if api_key and api_key != "Not found":
                logger.info(f"‚úÖ API kl√≠ƒç pro {service} naƒçten z backend API")
                return api_key
        
        logger.warning(f"‚ö†Ô∏è Backend API nevr√°tilo platn√Ω kl√≠ƒç pro {service}, zkou≈°√≠m environment variables")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Chyba p≈ôi naƒç√≠t√°n√≠ API kl√≠ƒçe z backend: {e}, zkou≈°√≠m environment variables")
    
    # Fallback na environment variables
    env_key_map = {
        "openai": "OPENAI_API_KEY"
    }
    
    env_var = env_key_map.get(service)
    if env_var:
        api_key = os.getenv(env_var)
        if api_key and api_key != "your-openai-api-key-here":
            logger.info(f"‚úÖ API kl√≠ƒç pro {service} naƒçten z environment variables")
            return api_key
    
    # ≈Ω√°dn√Ω platn√Ω kl√≠ƒç nenalezen
    raise Exception(f"API kl√≠ƒç pro slu≈æbu {service} nebyl nalezen ani v backend API ani v environment variables")

@activity.defn
async def load_assistants_from_database(project_id: str) -> list:
    """
    Naƒçte seznam asistent≈Ø pro dan√Ω projekt z datab√°ze
    POUZE fin√°ln√≠ 9 asistent≈Ø v p≈ôesn√©m po≈ôad√≠ - ≈æ√°dn√© testovac√≠ nebo legacy varianty!
    """
    try:
        logger.info(f"üîÑ Naƒç√≠t√°m FIN√ÅLN√ç asistenty pro projekt: {project_id}")
        
        # ‚úÖ FIN√ÅLN√ç SEO Pipeline - p≈ôesnƒõ 9 asistent≈Ø v dan√©m po≈ôad√≠
        final_assistants = [
            {
                "id": "brief_assistant",
                "name": "BriefAssistant", 
                "function_key": "brief_assistant",
                "slug": "brief_assistant",
                "system_prompt": "Jsi expert na vytv√°≈ôen√≠ brief≈Ø pro SEO obsah. Tv√Ωm √∫kolem je vytvo≈ôit strukturovan√Ω brief na z√°kladƒõ zadan√©ho t√©matu. Zamƒõ≈ô se na c√≠lovou skupinu, kl√≠ƒçov√© body, kter√© m√° obsah pokr√Ωt, hlavn√≠ c√≠le textu a oƒçek√°van√Ω rozsah obsahu.",
                "model": "gpt-4",
                "max_tokens": 2000,
                "order": 1,
                "input_keys": ["topic"],
                "output_keys": ["brief", "target_audience", "content_goals"]
            },
            {
                "id": "research_assistant",
                "name": "ResearchAssistant",
                "function_key": "research_assistant",
                "slug": "research_assistant", 
                "system_prompt": "Jsi research specialista. Analyzuje≈° zadan√© t√©ma podle briefu a vytv√°≈ô√≠≈° detailn√≠ v√Ωzkumn√© podklady. Hled√°≈° relevantn√≠ informace, aktu√°ln√≠ trendy, statistiky, expert n√°zory a konkurenƒçn√≠ anal√Ωzu k dan√©mu t√©matu.",
                "model": "gpt-4",
                "max_tokens": 3000,
                "order": 2,
                "input_keys": ["brief", "topic"],
                "output_keys": ["research_data", "statistics", "trends", "expert_opinions"]
            },
            {
                "id": "fact_validator_assistant",
                "name": "FactValidatorAssistant",
                "function_key": "fact_validator_assistant",
                "slug": "fact_validator_assistant",
                "system_prompt": "Jsi fact-checking specialista. Kontroluje≈° a ovƒõ≈ôuje≈° faktickou spr√°vnost informac√≠ z research dat. Identifikuje≈° potenci√°lnƒõ nep≈ôesn√© nebo zastaral√© informace a navrhne≈° jejich opravu nebo odstranƒõn√≠.",
                "model": "gpt-4",
                "max_tokens": 2500,
                "order": 3,
                "input_keys": ["research_data", "brief"],
                "output_keys": ["validated_facts", "fact_corrections", "reliability_score"]
            },
            {
                "id": "draft_assistant",
                "name": "DraftAssistant",
                "function_key": "draft_assistant",
                "slug": "draft_assistant",
                "system_prompt": "Jsi copywriter specialista na tvorbu prvn√≠ho n√°vrhu obsahu. Na z√°kladƒõ briefu a ovƒõ≈ôen√Ωch fakt≈Ø vytv√°≈ô√≠≈° strukturovan√Ω draft ƒçl√°nku s logick√Ωm pr≈Øtokem informac√≠ a z√°kladn√≠ SEO optimalizac√≠.",
                "model": "gpt-4",
                "max_tokens": 4000,
                "order": 4,
                "input_keys": ["brief", "validated_facts", "research_data"],
                "output_keys": ["content_draft", "article_structure", "key_points"]
            },
            {
                "id": "humanizer_assistant",
                "name": "HumanizerAssistant",
                "function_key": "humanizer_assistant",
                "slug": "humanizer_assistant",
                "system_prompt": "Jsi specialista na humanizaci obsahu. Bere≈° technick√Ω nebo such√Ω draft a p≈ôepisuje≈° ho do p≈ôirozen√©, ƒçtiv√© formy. Db√°≈° na osobn√≠ t√≥n, storytelling prvky, engagement a ƒçitelnost pro c√≠lovou skupinu.",
                "model": "gpt-4",
                "max_tokens": 4000,
                "order": 5,
                "input_keys": ["content_draft", "target_audience", "brief"],
                "output_keys": ["humanized_content", "engagement_elements", "readability_score"]
            },
            {
                "id": "seo_assistant",
                "name": "SEOAssistant",
                "function_key": "seo_assistant",
                "slug": "seo_assistant",
                "system_prompt": "Jsi SEO optimalizaƒçn√≠ expert. Ber≈°√≠ humanizovan√Ω obsah a optimalizuje≈° ho pro vyhled√°vaƒçe - keyword density, internal linking, meta tagy, heading struktura, schema markup a technical SEO best practices.",
                "model": "gpt-4",
                "max_tokens": 3000,
                "order": 6,
                "input_keys": ["humanized_content", "brief", "target_audience"],
                "output_keys": ["seo_optimized_content", "keywords", "meta_tags", "internal_links"]
            },
            {
                "id": "multimedia_assistant",
                "name": "MultimediaAssistant", 
                "function_key": "multimedia_assistant",
                "slug": "multimedia_assistant",
                "system_prompt": "Jsi multimedia content specialist. Analyzuje≈° SEO optimalizovan√Ω obsah a navrhne≈° multimedia prvky - obr√°zky, videa, infografiky, interaktivn√≠ prvky. Vytv√°≈ô√≠≈° detailn√≠ popisy a alt texty pro lep≈°√≠ SEO a user experience.",
                "model": "gpt-4",
                "max_tokens": 2500,
                "order": 7,
                "input_keys": ["seo_optimized_content", "brief"],
                "output_keys": ["multimedia_suggestions", "image_descriptions", "alt_texts", "video_concepts"]
            },
            {
                "id": "qa_assistant",
                "name": "QAAssistant",
                "function_key": "qa_assistant",
                "slug": "qa_assistant",
                "system_prompt": "Jsi quality assurance specialista. Prov√°d√≠≈° fin√°ln√≠ kontrolu kvality - gramatiku, stylistiku, faktickou spr√°vnost, SEO compliance, multimedia integrace a celkovou konzistenci obsahu p≈ôed publikov√°n√≠m.",
                "model": "gpt-4",
                "max_tokens": 2500,
                "order": 8,
                "input_keys": ["seo_optimized_content", "multimedia_suggestions", "brief"],
                "output_keys": ["qa_report", "final_corrections", "quality_score", "publication_ready"]
            },
            {
                "id": "publish_assistant",
                "name": "PublishAssistant",
                "function_key": "publish_assistant",
                "slug": "publish_assistant", 
                "system_prompt": "Jsi publishing specialist. P≈ôipravuje≈° fin√°ln√≠ obsah pro publikov√°n√≠ - CMS form√°tov√°n√≠, HTML markup, optimalizace pro rychlost naƒç√≠t√°n√≠, fin√°ln√≠ SEO kontrola a technick√© aspekty publikace.",
                "model": "gpt-4",
                "max_tokens": 2000,
                "order": 9,
                "input_keys": ["publication_ready", "multimedia_suggestions", "qa_report"],
                "output_keys": ["published_content", "cms_ready_html", "publication_metadata", "performance_optimized"]
            }
        ]
        
        # üîç STRIKTN√ç VALIDACE - kontrola pouze fin√°ln√≠ch asistent≈Ø
        expected_count = 9
        actual_count = len(final_assistants)
        
        # Kontrola poƒçtu asistent≈Ø
        if actual_count != expected_count:
            error_msg = f"‚ùå KRITICK√Å CHYBA: Oƒçek√°v√°no {expected_count} fin√°ln√≠ch asistent≈Ø, ale definov√°no {actual_count}!"
            logger.error(error_msg)
            raise Exception(error_msg)
        
        # Kontrola spr√°vn√©ho po≈ôad√≠ (1-9)
        orders = [assistant["order"] for assistant in final_assistants]
        expected_orders = list(range(1, 10))  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
        
        if orders != expected_orders:
            error_msg = f"‚ùå CHYBN√â PO≈òAD√ç: Oƒçek√°v√°no {expected_orders}, ale m√°me {orders}!"
            logger.error(error_msg)
            raise Exception(error_msg)
        
        # üö´ VALIDACE PROTI LEGACY/TESTOVAC√çM ASISTENT≈ÆM
        forbidden_slugs = [
            "keyword_assistant", "structure_assistant", "content_assistant", 
            "review_assistant", "meta_assistant",  # Legacy/testovac√≠ n√°zvy
            "test_assistant", "demo_assistant", "sample_assistant"  # Testovac√≠ varianty
        ]
        
        detected_forbidden = []
        for assistant in final_assistants:
            slug = assistant.get("slug", assistant.get("function_key", ""))
            if slug in forbidden_slugs:
                detected_forbidden.append(slug)
                logger.warning(f"‚ö†Ô∏è Detected invalid assistant in config: {slug}")
        
        if detected_forbidden:
            error_msg = f"‚ùå NEPLATN√ç ASISTENTI DETECTOV√ÅNI: {detected_forbidden}. Pou≈æijte pouze fin√°ln√≠ asistenty!"
            logger.error(error_msg)
            raise Exception(error_msg)
        
        # Kontrola unik√°tn√≠ch slug≈Ø
        slugs = [assistant["slug"] for assistant in final_assistants]
        if len(slugs) != len(set(slugs)):
            error_msg = f"‚ùå DUPLICITN√ç SLUGS DETECTED: {slugs}"
            logger.error(error_msg)
            raise Exception(error_msg)
        
        # Se≈ôazen√≠ podle order ASC (pro jistotu)
        final_assistants.sort(key=lambda x: x["order"])
        
        # ‚úÖ √öSPƒö≈†N√Å VALIDACE - detailn√≠ logy
        logger.info(f"‚úÖ NAƒåTENO {actual_count}/{expected_count} FIN√ÅLN√çCH ASISTENT≈Æ PRO PROJEKT {project_id}")
        logger.info("üìã FIN√ÅLN√ç ASISTENTI V PO≈òAD√ç:")
        for assistant in final_assistants:
            logger.info(f"  {assistant['order']}. {assistant['name']} ({assistant['slug']})")
        
        logger.info(f"üéØ FIN√ÅLN√ç PIPELINE P≈òIPRAVENA: {final_assistants[0]['name']} ‚Üí ... ‚Üí {final_assistants[-1]['name']}")
        logger.info("üö´ ≈Ω√ÅDN√ç legacy/testovac√≠ asistenti NEBYLI DETECTOV√ÅNI ‚úÖ")
        
        return final_assistants
        
    except Exception as e:
        logger.error(f"‚ùå Chyba p≈ôi naƒç√≠t√°n√≠ fin√°ln√≠ch asistent≈Ø: {str(e)}")
        raise

@activity.defn
async def execute_assistant(args: dict) -> dict:
    """
    Spust√≠ konkr√©tn√≠ho asistenta s danou konfigurac√≠
    
    Args:
        args: Dict obsahuj√≠c√≠:
            - assistant_config: dict - konfigurace asistenta
            - topic: str - t√©ma pro zpracov√°n√≠
            - previous_outputs: dict - p≈ôedchoz√≠ v√Ωstupy (optional)
    """
    assistant_config = args.get("assistant_config", {})
    topic = args.get("topic", "")
    previous_outputs = args.get("previous_outputs", {})
    
    assistant_name = assistant_config.get("name", "Unknown")
    function_key = assistant_config.get("function_key", "unknown")
    
    try:
        logger.info(f"ü§ñ Spou≈°t√≠m asistenta: {assistant_name}")
        logger.info(f"üìù Function Key: {function_key}")
        logger.info(f"üìã Input Length: {len(topic)} chars")
        
        # Z√≠sk√°n√≠ API kl√≠ƒçe z backend
        api_key = get_api_key("openai")
        
        # üîç DEBUG LOGY PRO API KL√çƒå AUDIT
        logger.info(f"üîë DEBUG: API key naƒçten: {'‚úÖ Ano' if api_key else '‚ùå Ne'}")
        logger.info(f"üîë DEBUG: API key prefix: {api_key[:10] if api_key else 'None'}...")
        logger.info(f"üîë DEBUG: API key d√©lka: {len(api_key) if api_key else 0} znak≈Ø")
        
        if not api_key:
            error_msg = "‚ùå CRITICAL: OpenAI API kl√≠ƒç nen√≠ dostupn√Ω!"
            logger.error(error_msg)
            raise Exception(error_msg)
        
        # Inicializace OpenAI klienta
        client = OpenAI(api_key=api_key)
        
        # Z√≠sk√°n√≠ konfigurace asistenta
        system_prompt = assistant_config.get("system_prompt", "Jsi pomocn√Ω AI asistent.")
        model = assistant_config.get("model", "gpt-4")
        max_tokens = assistant_config.get("max_tokens", 1000)
        
        # üîç DEBUG LOGY PRO OPENAI REQUEST
        logger.info(f"ü§ñ DEBUG: Model: {model}")
        logger.info(f"ü§ñ DEBUG: Max tokens: {max_tokens}")
        logger.info(f"ü§ñ DEBUG: Prompt d√©lka: {len(system_prompt)} znak≈Ø")
        logger.info(f"ü§ñ DEBUG: Topic d√©lka: {len(topic)} znak≈Ø")
        
        try:
            # Vol√°n√≠ OpenAI API
            logger.info(f"üîÑ Zaƒç√≠n√°m OpenAI API vol√°n√≠...")
            logger.info(f"üåê API endpoint: https://api.openai.com/v1/chat/completions")
            logger.info(f"üîë API key prefix: {api_key[:15]}...")
            
            # Heartbeat p≈ôed dlouh√Ωm OpenAI vol√°n√≠m
            activity.heartbeat()
            
            response = client.chat.completions.create(
                model=model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": topic}
                ],
                max_tokens=max_tokens
            )
            
            # Heartbeat po OpenAI vol√°n√≠
            activity.heartbeat()
            
            logger.info(f"‚úÖ OpenAI API response √∫spƒõ≈°n√Ω!")
            
            # üîç DEBUG LOGY PRO OPENAI RESPONSE
            logger.info(f"‚úÖ DEBUG: OpenAI response received")
            logger.info(f"‚úÖ DEBUG: Response model: {response.model}")
            logger.info(f"‚úÖ DEBUG: Usage tokens: {response.usage.total_tokens if response.usage else 'N/A'}")
            
            output = response.choices[0].message.content
            logger.info(f"‚úÖ DEBUG: Output d√©lka: {len(output)} znak≈Ø")
        
        except Exception as e:
            logger.error(f"‚ùå OpenAI API vol√°n√≠ selhalo!")
            logger.error(f"‚ùå Exception type: {type(e).__name__}")
            logger.error(f"‚ùå Exception message: {str(e)}")
            
            # Speci√°ln√≠ handling pro r≈Øzn√© typy chyb
            if "timeout" in str(e).lower():
                logger.error(f"‚è∞ TIMEOUT: OpenAI API vol√°n√≠ p≈ôekroƒçilo ƒçasov√Ω limit")
            elif "connection" in str(e).lower():
                logger.error(f"üåê CONNECTION: Probl√©m s p≈ôipojen√≠m k OpenAI API")
            elif "api_key" in str(e).lower() or "401" in str(e):
                logger.error(f"üîë AUTH: Probl√©m s API kl√≠ƒçem")
            elif "rate_limit" in str(e).lower() or "429" in str(e):
                logger.error(f"üö¶ RATE_LIMIT: P≈ôekroƒçen limit API vol√°n√≠")
            
            logger.error(f"‚ùå {assistant_name} selhal: {str(e)}")
            error_result = {
                "assistant_name": assistant_name,
                "function_key": function_key,
                "status": "failed",
                "error": str(e),
                "timestamp": datetime.now().isoformat()
            }
            raise Exception(f"Asistent {assistant_name} selhal: {str(e)}")
        
        # P≈ô√≠prava v√Ωsledku
        result = {
            "assistant_name": assistant_name,
            "function_key": function_key,
            "status": "completed",
            "output": output,
            "model_used": model,
            "tokens_used": response.usage.total_tokens if response.usage else 0,
            "timestamp": datetime.now().isoformat()
        }
        
        logger.info(f"‚úÖ {assistant_name} dokonƒçen √∫spƒõ≈°nƒõ")
        logger.info(f"üìä Pou≈æito token≈Ø: {result['tokens_used']}")
        logger.info(f"üìÑ V√Ωstup d√©lka: {len(output)} znak≈Ø")
        
        # üö® KRITICK√ù DEBUG LOG - potvrzen√≠, ≈æe funkce dobƒõhla a≈æ na konec
        logger.info(f"üéØ RETURNING RESULT: {assistant_name} - funkce execute_assistant() dokonƒçena √∫spƒõ≈°nƒõ, vrac√≠m result")
        logger.info(f"üéØ RESULT KEYS: {list(result.keys())}")
        logger.info(f"üéØ RESULT STATUS: {result.get('status', 'UNKNOWN')}")
        
        return result
        
    except Exception as e:
        logger.error(f"‚ùå {assistant_name} selhal: {str(e)}")
        error_result = {
            "assistant_name": assistant_name,
            "function_key": function_key,
            "status": "failed",
            "error": str(e),
            "timestamp": datetime.now().isoformat()
        }
        raise Exception(f"Asistent {assistant_name} selhal: {str(e)}")

@activity.defn
async def save_output_to_json(
    outputs: dict,
    topic: str,
    project_id: str
) -> dict:
    """
    Ulo≈æ√≠ fin√°ln√≠ v√Ωstupy do JSON souboru
    """
    try:
        logger.info(f"üíæ Ukl√°d√°m v√Ωstupy pro t√©ma: {topic}")
        
        # Vytvo≈ôen√≠ v√Ωsledn√©ho JSON objektu
        result = {
            "topic": topic,
            "project_id": project_id,
            "timestamp": datetime.now().isoformat(),
            "assistants": outputs,
            "status": "completed"
        }
        
        # Pro development jen logujeme, v produkci by se ukl√°dalo do datab√°ze/souboru
        logger.info(f"üìã Fin√°ln√≠ v√Ωstup p≈ôipraven ({len(str(result))} znak≈Ø)")
        logger.info(f"ü§ñ Poƒçet asistent≈Ø: {len(outputs)}")
        
        return result
        
    except Exception as e:
        logger.error(f"‚ùå Chyba p≈ôi ukl√°d√°n√≠ v√Ωstup≈Ø: {str(e)}")
        raise 