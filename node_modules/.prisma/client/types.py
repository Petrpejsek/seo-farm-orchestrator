# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
                    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
                    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
                    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
                    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                            },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# Project types

class ProjectOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Project create method"""
    id: _str
    language: _str
    description: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    assistants: 'AssistantCreateManyNestedWithoutRelationsInput'
    workflowRuns: 'WorkflowRunCreateManyNestedWithoutRelationsInput'


class ProjectCreateInput(ProjectOptionalCreateInput):
    """Required arguments to the Project create method"""
    name: _str
    slug: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ProjectOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Project create method, without relations"""
    id: _str
    language: _str
    description: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ProjectCreateWithoutRelationsInput(ProjectOptionalCreateWithoutRelationsInput):
    """Required arguments to the Project create method, without relations"""
    name: _str
    slug: _str

class ProjectConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ProjectCreateWithoutRelationsInput'
    where: 'ProjectWhereUniqueInput'

class ProjectCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ProjectCreateWithoutRelationsInput'
    connect: 'ProjectWhereUniqueInput'
    connect_or_create: 'ProjectConnectOrCreateWithoutRelationsInput'


class ProjectCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ProjectCreateWithoutRelationsInput', List['ProjectCreateWithoutRelationsInput']]
    connect: Union['ProjectWhereUniqueInput', List['ProjectWhereUniqueInput']]
    connect_or_create: Union['ProjectConnectOrCreateWithoutRelationsInput', List['ProjectConnectOrCreateWithoutRelationsInput']]

_ProjectWhereUnique_id_Input = TypedDict(
    '_ProjectWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_ProjectWhereUnique_slug_Input = TypedDict(
    '_ProjectWhereUnique_slug_Input',
    {
        'slug': '_str',
    },
    total=True
)

ProjectWhereUniqueInput = Union[
    '_ProjectWhereUnique_id_Input',
    '_ProjectWhereUnique_slug_Input',
]


class ProjectUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    slug: _str
    language: _str
    description: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    assistants: 'AssistantUpdateManyWithoutRelationsInput'
    workflowRuns: 'WorkflowRunUpdateManyWithoutRelationsInput'


class ProjectUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    slug: _str
    language: _str
    description: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ProjectUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ProjectCreateWithoutRelationsInput']
    connect: List['ProjectWhereUniqueInput']
    connect_or_create: List['ProjectConnectOrCreateWithoutRelationsInput']
    set: List['ProjectWhereUniqueInput']
    disconnect: List['ProjectWhereUniqueInput']
    delete: List['ProjectWhereUniqueInput']

    # TODO
    # update: List['ProjectUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ProjectUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ProjectScalarWhereInput']
    # upsert: List['ProjectUpserteWithWhereUniqueWithoutRelationsInput']


class ProjectUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ProjectCreateWithoutRelationsInput'
    connect: 'ProjectWhereUniqueInput'
    connect_or_create: 'ProjectConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ProjectUpdateInput'
    # upsert: 'ProjectUpsertWithoutRelationsInput'


class ProjectUpsertInput(TypedDict):
    create: 'ProjectCreateInput'
    update: 'ProjectUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Project_id_OrderByInput = TypedDict(
    '_Project_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Project_name_OrderByInput = TypedDict(
    '_Project_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Project_slug_OrderByInput = TypedDict(
    '_Project_slug_OrderByInput',
    {
        'slug': 'SortOrder',
    },
    total=True
)

_Project_language_OrderByInput = TypedDict(
    '_Project_language_OrderByInput',
    {
        'language': 'SortOrder',
    },
    total=True
)

_Project_description_OrderByInput = TypedDict(
    '_Project_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Project_createdAt_OrderByInput = TypedDict(
    '_Project_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Project_updatedAt_OrderByInput = TypedDict(
    '_Project_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

ProjectOrderByInput = Union[
    '_Project_id_OrderByInput',
    '_Project_name_OrderByInput',
    '_Project_slug_OrderByInput',
    '_Project_language_OrderByInput',
    '_Project_description_OrderByInput',
    '_Project_createdAt_OrderByInput',
    '_Project_updatedAt_OrderByInput',
]



# recursive Project types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ProjectRelationFilter = TypedDict(
    'ProjectRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class ProjectListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class ProjectInclude(TypedDict, total=False):
    """Project relational arguments"""
    assistants: Union[bool, 'FindManyAssistantArgsFromProject']
    workflowRuns: Union[bool, 'FindManyWorkflowRunArgsFromProject']


    

class ProjectIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    assistants: Union[bool, 'FindManyAssistantArgsFromProjectRecursive1']
    workflowRuns: Union[bool, 'FindManyWorkflowRunArgsFromProjectRecursive1']


class ProjectIncludeFromProjectRecursive1(TypedDict, total=False):
    """Relational arguments for Project"""
    assistants: Union[bool, 'FindManyAssistantArgsFromProjectRecursive2']
    workflowRuns: Union[bool, 'FindManyWorkflowRunArgsFromProjectRecursive2']


class ProjectIncludeFromProjectRecursive2(TypedDict, total=False):
    """Relational arguments for Project"""
    assistants: Union[bool, 'FindManyAssistantArgsFromProjectRecursive3']
    workflowRuns: Union[bool, 'FindManyWorkflowRunArgsFromProjectRecursive3']


class ProjectIncludeFromProjectRecursive3(TypedDict, total=False):
    """Relational arguments for Project"""
    assistants: Union[bool, 'FindManyAssistantArgsFromProjectRecursive4']
    workflowRuns: Union[bool, 'FindManyWorkflowRunArgsFromProjectRecursive4']


class ProjectIncludeFromProjectRecursive4(TypedDict, total=False):
    """Relational arguments for Project"""

    

class ProjectArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'ProjectIncludeFromProjectRecursive1'


class ProjectArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    include: 'ProjectIncludeFromProjectRecursive2'


class ProjectArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    include: 'ProjectIncludeFromProjectRecursive3'


class ProjectArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    include: 'ProjectIncludeFromProjectRecursive4'


class ProjectArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    
    

class FindManyProjectArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive1'


class FindManyProjectArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive2'


class FindManyProjectArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive3'


class FindManyProjectArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive4'


class FindManyProjectArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    
    

class AssistantIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    project: Union[bool, 'ProjectArgsFromProjectRecursive1']


class AssistantIncludeFromProjectRecursive1(TypedDict, total=False):
    """Relational arguments for Project"""
    project: Union[bool, 'ProjectArgsFromProjectRecursive2']


class AssistantIncludeFromProjectRecursive2(TypedDict, total=False):
    """Relational arguments for Project"""
    project: Union[bool, 'ProjectArgsFromProjectRecursive3']


class AssistantIncludeFromProjectRecursive3(TypedDict, total=False):
    """Relational arguments for Project"""
    project: Union[bool, 'ProjectArgsFromProjectRecursive4']


class AssistantIncludeFromProjectRecursive4(TypedDict, total=False):
    """Relational arguments for Project"""

    

class AssistantArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'AssistantIncludeFromAssistantRecursive1'


class AssistantArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    include: 'AssistantIncludeFromAssistantRecursive2'


class AssistantArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    include: 'AssistantIncludeFromAssistantRecursive3'


class AssistantArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    include: 'AssistantIncludeFromAssistantRecursive4'


class AssistantArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    
    

class FindManyAssistantArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['AssistantOrderByInput', List['AssistantOrderByInput']]
    where: 'AssistantWhereInput'
    cursor: 'AssistantWhereUniqueInput'
    distinct: List['AssistantScalarFieldKeys']
    include: 'AssistantIncludeFromAssistantRecursive1'


class FindManyAssistantArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['AssistantOrderByInput', List['AssistantOrderByInput']]
    where: 'AssistantWhereInput'
    cursor: 'AssistantWhereUniqueInput'
    distinct: List['AssistantScalarFieldKeys']
    include: 'AssistantIncludeFromAssistantRecursive2'


class FindManyAssistantArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['AssistantOrderByInput', List['AssistantOrderByInput']]
    where: 'AssistantWhereInput'
    cursor: 'AssistantWhereUniqueInput'
    distinct: List['AssistantScalarFieldKeys']
    include: 'AssistantIncludeFromAssistantRecursive3'


class FindManyAssistantArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['AssistantOrderByInput', List['AssistantOrderByInput']]
    where: 'AssistantWhereInput'
    cursor: 'AssistantWhereUniqueInput'
    distinct: List['AssistantScalarFieldKeys']
    include: 'AssistantIncludeFromAssistantRecursive4'


class FindManyAssistantArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['AssistantOrderByInput', List['AssistantOrderByInput']]
    where: 'AssistantWhereInput'
    cursor: 'AssistantWhereUniqueInput'
    distinct: List['AssistantScalarFieldKeys']
    
    

class WorkflowRunIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    project: Union[bool, 'ProjectArgsFromProjectRecursive1']


class WorkflowRunIncludeFromProjectRecursive1(TypedDict, total=False):
    """Relational arguments for Project"""
    project: Union[bool, 'ProjectArgsFromProjectRecursive2']


class WorkflowRunIncludeFromProjectRecursive2(TypedDict, total=False):
    """Relational arguments for Project"""
    project: Union[bool, 'ProjectArgsFromProjectRecursive3']


class WorkflowRunIncludeFromProjectRecursive3(TypedDict, total=False):
    """Relational arguments for Project"""
    project: Union[bool, 'ProjectArgsFromProjectRecursive4']


class WorkflowRunIncludeFromProjectRecursive4(TypedDict, total=False):
    """Relational arguments for Project"""

    

class WorkflowRunArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive1'


class WorkflowRunArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive2'


class WorkflowRunArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive3'


class WorkflowRunArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive4'


class WorkflowRunArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    
    

class FindManyWorkflowRunArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['WorkflowRunOrderByInput', List['WorkflowRunOrderByInput']]
    where: 'WorkflowRunWhereInput'
    cursor: 'WorkflowRunWhereUniqueInput'
    distinct: List['WorkflowRunScalarFieldKeys']
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive1'


class FindManyWorkflowRunArgsFromProjectRecursive1(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['WorkflowRunOrderByInput', List['WorkflowRunOrderByInput']]
    where: 'WorkflowRunWhereInput'
    cursor: 'WorkflowRunWhereUniqueInput'
    distinct: List['WorkflowRunScalarFieldKeys']
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive2'


class FindManyWorkflowRunArgsFromProjectRecursive2(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['WorkflowRunOrderByInput', List['WorkflowRunOrderByInput']]
    where: 'WorkflowRunWhereInput'
    cursor: 'WorkflowRunWhereUniqueInput'
    distinct: List['WorkflowRunScalarFieldKeys']
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive3'


class FindManyWorkflowRunArgsFromProjectRecursive3(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['WorkflowRunOrderByInput', List['WorkflowRunOrderByInput']]
    where: 'WorkflowRunWhereInput'
    cursor: 'WorkflowRunWhereUniqueInput'
    distinct: List['WorkflowRunScalarFieldKeys']
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive4'


class FindManyWorkflowRunArgsFromProjectRecursive4(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['WorkflowRunOrderByInput', List['WorkflowRunOrderByInput']]
    where: 'WorkflowRunWhereInput'
    cursor: 'WorkflowRunWhereUniqueInput'
    distinct: List['WorkflowRunScalarFieldKeys']
    


FindManyProjectArgs = FindManyProjectArgsFromProject
FindFirstProjectArgs = FindManyProjectArgsFromProject


    

class ProjectWhereInput(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    slug: Union[_str, 'types.StringFilter']
    language: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    assistants: 'AssistantListRelationFilter'
    workflowRuns: 'WorkflowRunListRelationFilter'

    # should be noted that AND and NOT should be Union['ProjectWhereInputRecursive1', List['ProjectWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['ProjectWhereInputRecursive1']
    OR: List['ProjectWhereInputRecursive1']
    NOT: List['ProjectWhereInputRecursive1']


class ProjectWhereInputRecursive1(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    slug: Union[_str, 'types.StringFilter']
    language: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    assistants: 'AssistantListRelationFilter'
    workflowRuns: 'WorkflowRunListRelationFilter'

    # should be noted that AND and NOT should be Union['ProjectWhereInputRecursive2', List['ProjectWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['ProjectWhereInputRecursive2']
    OR: List['ProjectWhereInputRecursive2']
    NOT: List['ProjectWhereInputRecursive2']


class ProjectWhereInputRecursive2(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    slug: Union[_str, 'types.StringFilter']
    language: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    assistants: 'AssistantListRelationFilter'
    workflowRuns: 'WorkflowRunListRelationFilter'

    # should be noted that AND and NOT should be Union['ProjectWhereInputRecursive3', List['ProjectWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['ProjectWhereInputRecursive3']
    OR: List['ProjectWhereInputRecursive3']
    NOT: List['ProjectWhereInputRecursive3']


class ProjectWhereInputRecursive3(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    slug: Union[_str, 'types.StringFilter']
    language: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    assistants: 'AssistantListRelationFilter'
    workflowRuns: 'WorkflowRunListRelationFilter'

    # should be noted that AND and NOT should be Union['ProjectWhereInputRecursive4', List['ProjectWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['ProjectWhereInputRecursive4']
    OR: List['ProjectWhereInputRecursive4']
    NOT: List['ProjectWhereInputRecursive4']


class ProjectWhereInputRecursive4(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    slug: Union[_str, 'types.StringFilter']
    language: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    assistants: 'AssistantListRelationFilter'
    workflowRuns: 'WorkflowRunListRelationFilter'



# aggregate Project types


    

class ProjectScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    language: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProjectScalarWhereWithAggregatesInputRecursive1']
    OR: List['ProjectScalarWhereWithAggregatesInputRecursive1']
    NOT: List['ProjectScalarWhereWithAggregatesInputRecursive1']


class ProjectScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    language: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProjectScalarWhereWithAggregatesInputRecursive2']
    OR: List['ProjectScalarWhereWithAggregatesInputRecursive2']
    NOT: List['ProjectScalarWhereWithAggregatesInputRecursive2']


class ProjectScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    language: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProjectScalarWhereWithAggregatesInputRecursive3']
    OR: List['ProjectScalarWhereWithAggregatesInputRecursive3']
    NOT: List['ProjectScalarWhereWithAggregatesInputRecursive3']


class ProjectScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    language: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProjectScalarWhereWithAggregatesInputRecursive4']
    OR: List['ProjectScalarWhereWithAggregatesInputRecursive4']
    NOT: List['ProjectScalarWhereWithAggregatesInputRecursive4']


class ProjectScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    language: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class ProjectGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    slug: _str
    language: _str
    description: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'ProjectSumAggregateOutput'
    _avg: 'ProjectAvgAggregateOutput'
    _min: 'ProjectMinAggregateOutput'
    _max: 'ProjectMaxAggregateOutput'
    _count: 'ProjectCountAggregateOutput'


class ProjectAvgAggregateOutput(TypedDict, total=False):
    """Project output for aggregating averages"""


class ProjectSumAggregateOutput(TypedDict, total=False):
    """Project output for aggregating sums"""


class ProjectScalarAggregateOutput(TypedDict, total=False):
    """Project output including scalar fields"""
    id: _str
    name: _str
    slug: _str
    language: _str
    description: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


ProjectMinAggregateOutput = ProjectScalarAggregateOutput
ProjectMaxAggregateOutput = ProjectScalarAggregateOutput


class ProjectMaxAggregateInput(TypedDict, total=False):
    """Project input for aggregating by max"""
    id: bool
    name: bool
    slug: bool
    language: bool
    description: bool
    createdAt: bool
    updatedAt: bool


class ProjectMinAggregateInput(TypedDict, total=False):
    """Project input for aggregating by min"""
    id: bool
    name: bool
    slug: bool
    language: bool
    description: bool
    createdAt: bool
    updatedAt: bool


class ProjectNumberAggregateInput(TypedDict, total=False):
    """Project input for aggregating numbers"""


ProjectAvgAggregateInput = ProjectNumberAggregateInput
ProjectSumAggregateInput = ProjectNumberAggregateInput


ProjectCountAggregateInput = TypedDict(
    'ProjectCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'slug': bool,
        'language': bool,
        'description': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

ProjectCountAggregateOutput = TypedDict(
    'ProjectCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'slug': int,
        'language': int,
        'description': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


ProjectKeys = Literal[
    'id',
    'name',
    'slug',
    'language',
    'description',
    'createdAt',
    'updatedAt',
    'assistants',
    'workflowRuns',
]
ProjectScalarFieldKeys = Literal[
    'id',
    'name',
    'slug',
    'language',
    'description',
    'createdAt',
    'updatedAt',
]
ProjectScalarFieldKeysT = TypeVar('ProjectScalarFieldKeysT', bound=ProjectScalarFieldKeys)

ProjectRelationalFieldKeys = Literal[
        'assistants',
        'workflowRuns',
    ]

# Assistant types

class AssistantOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Assistant create method"""
    id: _str
    projectId: _str
    inputType: _str
    outputType: _str
    timeout: _int
    heartbeat: _int
    active: _bool
    description: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    project: 'ProjectCreateNestedWithoutRelationsInput'


class AssistantCreateInput(AssistantOptionalCreateInput):
    """Required arguments to the Assistant create method"""
    name: _str
    functionKey: _str
    order: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class AssistantOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Assistant create method, without relations"""
    id: _str
    projectId: _str
    inputType: _str
    outputType: _str
    timeout: _int
    heartbeat: _int
    active: _bool
    description: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AssistantCreateWithoutRelationsInput(AssistantOptionalCreateWithoutRelationsInput):
    """Required arguments to the Assistant create method, without relations"""
    name: _str
    functionKey: _str
    order: _int

class AssistantConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'AssistantCreateWithoutRelationsInput'
    where: 'AssistantWhereUniqueInput'

class AssistantCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'AssistantCreateWithoutRelationsInput'
    connect: 'AssistantWhereUniqueInput'
    connect_or_create: 'AssistantConnectOrCreateWithoutRelationsInput'


class AssistantCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['AssistantCreateWithoutRelationsInput', List['AssistantCreateWithoutRelationsInput']]
    connect: Union['AssistantWhereUniqueInput', List['AssistantWhereUniqueInput']]
    connect_or_create: Union['AssistantConnectOrCreateWithoutRelationsInput', List['AssistantConnectOrCreateWithoutRelationsInput']]

_AssistantWhereUnique_id_Input = TypedDict(
    '_AssistantWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_AssistantCompoundprojectId_orderKeyInner = TypedDict(
    '_AssistantCompoundprojectId_orderKeyInner',
    {
        'projectId': '_str',
        'order': '_int',
    },
    total=True
)

_AssistantCompoundprojectId_orderKey = TypedDict(
    '_AssistantCompoundprojectId_orderKey',
    {
        'projectId_order': '_AssistantCompoundprojectId_orderKeyInner',
    },
    total=True
)

AssistantWhereUniqueInput = Union[
    '_AssistantWhereUnique_id_Input',
    '_AssistantCompoundprojectId_orderKey',
]


class AssistantUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    functionKey: _str
    inputType: _str
    outputType: _str
    order: Union[AtomicIntInput, _int]
    timeout: Union[AtomicIntInput, _int]
    heartbeat: Union[AtomicIntInput, _int]
    active: _bool
    description: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    project: 'ProjectUpdateOneWithoutRelationsInput'


class AssistantUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    functionKey: _str
    inputType: _str
    outputType: _str
    order: Union[AtomicIntInput, _int]
    timeout: Union[AtomicIntInput, _int]
    heartbeat: Union[AtomicIntInput, _int]
    active: _bool
    description: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AssistantUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['AssistantCreateWithoutRelationsInput']
    connect: List['AssistantWhereUniqueInput']
    connect_or_create: List['AssistantConnectOrCreateWithoutRelationsInput']
    set: List['AssistantWhereUniqueInput']
    disconnect: List['AssistantWhereUniqueInput']
    delete: List['AssistantWhereUniqueInput']

    # TODO
    # update: List['AssistantUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['AssistantUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['AssistantScalarWhereInput']
    # upsert: List['AssistantUpserteWithWhereUniqueWithoutRelationsInput']


class AssistantUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'AssistantCreateWithoutRelationsInput'
    connect: 'AssistantWhereUniqueInput'
    connect_or_create: 'AssistantConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'AssistantUpdateInput'
    # upsert: 'AssistantUpsertWithoutRelationsInput'


class AssistantUpsertInput(TypedDict):
    create: 'AssistantCreateInput'
    update: 'AssistantUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Assistant_id_OrderByInput = TypedDict(
    '_Assistant_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Assistant_projectId_OrderByInput = TypedDict(
    '_Assistant_projectId_OrderByInput',
    {
        'projectId': 'SortOrder',
    },
    total=True
)

_Assistant_name_OrderByInput = TypedDict(
    '_Assistant_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Assistant_functionKey_OrderByInput = TypedDict(
    '_Assistant_functionKey_OrderByInput',
    {
        'functionKey': 'SortOrder',
    },
    total=True
)

_Assistant_inputType_OrderByInput = TypedDict(
    '_Assistant_inputType_OrderByInput',
    {
        'inputType': 'SortOrder',
    },
    total=True
)

_Assistant_outputType_OrderByInput = TypedDict(
    '_Assistant_outputType_OrderByInput',
    {
        'outputType': 'SortOrder',
    },
    total=True
)

_Assistant_order_OrderByInput = TypedDict(
    '_Assistant_order_OrderByInput',
    {
        'order': 'SortOrder',
    },
    total=True
)

_Assistant_timeout_OrderByInput = TypedDict(
    '_Assistant_timeout_OrderByInput',
    {
        'timeout': 'SortOrder',
    },
    total=True
)

_Assistant_heartbeat_OrderByInput = TypedDict(
    '_Assistant_heartbeat_OrderByInput',
    {
        'heartbeat': 'SortOrder',
    },
    total=True
)

_Assistant_active_OrderByInput = TypedDict(
    '_Assistant_active_OrderByInput',
    {
        'active': 'SortOrder',
    },
    total=True
)

_Assistant_description_OrderByInput = TypedDict(
    '_Assistant_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Assistant_createdAt_OrderByInput = TypedDict(
    '_Assistant_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Assistant_updatedAt_OrderByInput = TypedDict(
    '_Assistant_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

AssistantOrderByInput = Union[
    '_Assistant_id_OrderByInput',
    '_Assistant_projectId_OrderByInput',
    '_Assistant_name_OrderByInput',
    '_Assistant_functionKey_OrderByInput',
    '_Assistant_inputType_OrderByInput',
    '_Assistant_outputType_OrderByInput',
    '_Assistant_order_OrderByInput',
    '_Assistant_timeout_OrderByInput',
    '_Assistant_heartbeat_OrderByInput',
    '_Assistant_active_OrderByInput',
    '_Assistant_description_OrderByInput',
    '_Assistant_createdAt_OrderByInput',
    '_Assistant_updatedAt_OrderByInput',
]



# recursive Assistant types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

AssistantRelationFilter = TypedDict(
    'AssistantRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class AssistantListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class AssistantInclude(TypedDict, total=False):
    """Assistant relational arguments"""
    project: Union[bool, 'ProjectArgsFromAssistant']


    

class ProjectIncludeFromAssistant(TypedDict, total=False):
    """Relational arguments for Assistant"""
    assistants: Union[bool, 'FindManyAssistantArgsFromAssistantRecursive1']
    workflowRuns: Union[bool, 'FindManyWorkflowRunArgsFromAssistantRecursive1']


class ProjectIncludeFromAssistantRecursive1(TypedDict, total=False):
    """Relational arguments for Assistant"""
    assistants: Union[bool, 'FindManyAssistantArgsFromAssistantRecursive2']
    workflowRuns: Union[bool, 'FindManyWorkflowRunArgsFromAssistantRecursive2']


class ProjectIncludeFromAssistantRecursive2(TypedDict, total=False):
    """Relational arguments for Assistant"""
    assistants: Union[bool, 'FindManyAssistantArgsFromAssistantRecursive3']
    workflowRuns: Union[bool, 'FindManyWorkflowRunArgsFromAssistantRecursive3']


class ProjectIncludeFromAssistantRecursive3(TypedDict, total=False):
    """Relational arguments for Assistant"""
    assistants: Union[bool, 'FindManyAssistantArgsFromAssistantRecursive4']
    workflowRuns: Union[bool, 'FindManyWorkflowRunArgsFromAssistantRecursive4']


class ProjectIncludeFromAssistantRecursive4(TypedDict, total=False):
    """Relational arguments for Assistant"""

    

class ProjectArgsFromAssistant(TypedDict, total=False):
    """Arguments for Assistant"""
    include: 'ProjectIncludeFromProjectRecursive1'


class ProjectArgsFromAssistantRecursive1(TypedDict, total=False):
    """Arguments for Assistant"""
    include: 'ProjectIncludeFromProjectRecursive2'


class ProjectArgsFromAssistantRecursive2(TypedDict, total=False):
    """Arguments for Assistant"""
    include: 'ProjectIncludeFromProjectRecursive3'


class ProjectArgsFromAssistantRecursive3(TypedDict, total=False):
    """Arguments for Assistant"""
    include: 'ProjectIncludeFromProjectRecursive4'


class ProjectArgsFromAssistantRecursive4(TypedDict, total=False):
    """Arguments for Assistant"""
    
    

class FindManyProjectArgsFromAssistant(TypedDict, total=False):
    """Arguments for Assistant"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive1'


class FindManyProjectArgsFromAssistantRecursive1(TypedDict, total=False):
    """Arguments for Assistant"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive2'


class FindManyProjectArgsFromAssistantRecursive2(TypedDict, total=False):
    """Arguments for Assistant"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive3'


class FindManyProjectArgsFromAssistantRecursive3(TypedDict, total=False):
    """Arguments for Assistant"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive4'


class FindManyProjectArgsFromAssistantRecursive4(TypedDict, total=False):
    """Arguments for Assistant"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    
    

class AssistantIncludeFromAssistant(TypedDict, total=False):
    """Relational arguments for Assistant"""
    project: Union[bool, 'ProjectArgsFromAssistantRecursive1']


class AssistantIncludeFromAssistantRecursive1(TypedDict, total=False):
    """Relational arguments for Assistant"""
    project: Union[bool, 'ProjectArgsFromAssistantRecursive2']


class AssistantIncludeFromAssistantRecursive2(TypedDict, total=False):
    """Relational arguments for Assistant"""
    project: Union[bool, 'ProjectArgsFromAssistantRecursive3']


class AssistantIncludeFromAssistantRecursive3(TypedDict, total=False):
    """Relational arguments for Assistant"""
    project: Union[bool, 'ProjectArgsFromAssistantRecursive4']


class AssistantIncludeFromAssistantRecursive4(TypedDict, total=False):
    """Relational arguments for Assistant"""

    

class AssistantArgsFromAssistant(TypedDict, total=False):
    """Arguments for Assistant"""
    include: 'AssistantIncludeFromAssistantRecursive1'


class AssistantArgsFromAssistantRecursive1(TypedDict, total=False):
    """Arguments for Assistant"""
    include: 'AssistantIncludeFromAssistantRecursive2'


class AssistantArgsFromAssistantRecursive2(TypedDict, total=False):
    """Arguments for Assistant"""
    include: 'AssistantIncludeFromAssistantRecursive3'


class AssistantArgsFromAssistantRecursive3(TypedDict, total=False):
    """Arguments for Assistant"""
    include: 'AssistantIncludeFromAssistantRecursive4'


class AssistantArgsFromAssistantRecursive4(TypedDict, total=False):
    """Arguments for Assistant"""
    
    

class FindManyAssistantArgsFromAssistant(TypedDict, total=False):
    """Arguments for Assistant"""
    take: int
    skip: int
    order_by: Union['AssistantOrderByInput', List['AssistantOrderByInput']]
    where: 'AssistantWhereInput'
    cursor: 'AssistantWhereUniqueInput'
    distinct: List['AssistantScalarFieldKeys']
    include: 'AssistantIncludeFromAssistantRecursive1'


class FindManyAssistantArgsFromAssistantRecursive1(TypedDict, total=False):
    """Arguments for Assistant"""
    take: int
    skip: int
    order_by: Union['AssistantOrderByInput', List['AssistantOrderByInput']]
    where: 'AssistantWhereInput'
    cursor: 'AssistantWhereUniqueInput'
    distinct: List['AssistantScalarFieldKeys']
    include: 'AssistantIncludeFromAssistantRecursive2'


class FindManyAssistantArgsFromAssistantRecursive2(TypedDict, total=False):
    """Arguments for Assistant"""
    take: int
    skip: int
    order_by: Union['AssistantOrderByInput', List['AssistantOrderByInput']]
    where: 'AssistantWhereInput'
    cursor: 'AssistantWhereUniqueInput'
    distinct: List['AssistantScalarFieldKeys']
    include: 'AssistantIncludeFromAssistantRecursive3'


class FindManyAssistantArgsFromAssistantRecursive3(TypedDict, total=False):
    """Arguments for Assistant"""
    take: int
    skip: int
    order_by: Union['AssistantOrderByInput', List['AssistantOrderByInput']]
    where: 'AssistantWhereInput'
    cursor: 'AssistantWhereUniqueInput'
    distinct: List['AssistantScalarFieldKeys']
    include: 'AssistantIncludeFromAssistantRecursive4'


class FindManyAssistantArgsFromAssistantRecursive4(TypedDict, total=False):
    """Arguments for Assistant"""
    take: int
    skip: int
    order_by: Union['AssistantOrderByInput', List['AssistantOrderByInput']]
    where: 'AssistantWhereInput'
    cursor: 'AssistantWhereUniqueInput'
    distinct: List['AssistantScalarFieldKeys']
    
    

class WorkflowRunIncludeFromAssistant(TypedDict, total=False):
    """Relational arguments for Assistant"""
    project: Union[bool, 'ProjectArgsFromAssistantRecursive1']


class WorkflowRunIncludeFromAssistantRecursive1(TypedDict, total=False):
    """Relational arguments for Assistant"""
    project: Union[bool, 'ProjectArgsFromAssistantRecursive2']


class WorkflowRunIncludeFromAssistantRecursive2(TypedDict, total=False):
    """Relational arguments for Assistant"""
    project: Union[bool, 'ProjectArgsFromAssistantRecursive3']


class WorkflowRunIncludeFromAssistantRecursive3(TypedDict, total=False):
    """Relational arguments for Assistant"""
    project: Union[bool, 'ProjectArgsFromAssistantRecursive4']


class WorkflowRunIncludeFromAssistantRecursive4(TypedDict, total=False):
    """Relational arguments for Assistant"""

    

class WorkflowRunArgsFromAssistant(TypedDict, total=False):
    """Arguments for Assistant"""
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive1'


class WorkflowRunArgsFromAssistantRecursive1(TypedDict, total=False):
    """Arguments for Assistant"""
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive2'


class WorkflowRunArgsFromAssistantRecursive2(TypedDict, total=False):
    """Arguments for Assistant"""
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive3'


class WorkflowRunArgsFromAssistantRecursive3(TypedDict, total=False):
    """Arguments for Assistant"""
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive4'


class WorkflowRunArgsFromAssistantRecursive4(TypedDict, total=False):
    """Arguments for Assistant"""
    
    

class FindManyWorkflowRunArgsFromAssistant(TypedDict, total=False):
    """Arguments for Assistant"""
    take: int
    skip: int
    order_by: Union['WorkflowRunOrderByInput', List['WorkflowRunOrderByInput']]
    where: 'WorkflowRunWhereInput'
    cursor: 'WorkflowRunWhereUniqueInput'
    distinct: List['WorkflowRunScalarFieldKeys']
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive1'


class FindManyWorkflowRunArgsFromAssistantRecursive1(TypedDict, total=False):
    """Arguments for Assistant"""
    take: int
    skip: int
    order_by: Union['WorkflowRunOrderByInput', List['WorkflowRunOrderByInput']]
    where: 'WorkflowRunWhereInput'
    cursor: 'WorkflowRunWhereUniqueInput'
    distinct: List['WorkflowRunScalarFieldKeys']
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive2'


class FindManyWorkflowRunArgsFromAssistantRecursive2(TypedDict, total=False):
    """Arguments for Assistant"""
    take: int
    skip: int
    order_by: Union['WorkflowRunOrderByInput', List['WorkflowRunOrderByInput']]
    where: 'WorkflowRunWhereInput'
    cursor: 'WorkflowRunWhereUniqueInput'
    distinct: List['WorkflowRunScalarFieldKeys']
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive3'


class FindManyWorkflowRunArgsFromAssistantRecursive3(TypedDict, total=False):
    """Arguments for Assistant"""
    take: int
    skip: int
    order_by: Union['WorkflowRunOrderByInput', List['WorkflowRunOrderByInput']]
    where: 'WorkflowRunWhereInput'
    cursor: 'WorkflowRunWhereUniqueInput'
    distinct: List['WorkflowRunScalarFieldKeys']
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive4'


class FindManyWorkflowRunArgsFromAssistantRecursive4(TypedDict, total=False):
    """Arguments for Assistant"""
    take: int
    skip: int
    order_by: Union['WorkflowRunOrderByInput', List['WorkflowRunOrderByInput']]
    where: 'WorkflowRunWhereInput'
    cursor: 'WorkflowRunWhereUniqueInput'
    distinct: List['WorkflowRunScalarFieldKeys']
    


FindManyAssistantArgs = FindManyAssistantArgsFromAssistant
FindFirstAssistantArgs = FindManyAssistantArgsFromAssistant


    

class AssistantWhereInput(TypedDict, total=False):
    """Assistant arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    projectId: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    functionKey: Union[_str, 'types.StringFilter']
    inputType: Union[_str, 'types.StringFilter']
    outputType: Union[_str, 'types.StringFilter']
    order: Union[_int, 'types.IntFilter']
    timeout: Union[_int, 'types.IntFilter']
    heartbeat: Union[_int, 'types.IntFilter']
    active: Union[_bool, 'types.BooleanFilter']
    description: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    project: 'ProjectRelationFilter'

    # should be noted that AND and NOT should be Union['AssistantWhereInputRecursive1', List['AssistantWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['AssistantWhereInputRecursive1']
    OR: List['AssistantWhereInputRecursive1']
    NOT: List['AssistantWhereInputRecursive1']


class AssistantWhereInputRecursive1(TypedDict, total=False):
    """Assistant arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    projectId: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    functionKey: Union[_str, 'types.StringFilter']
    inputType: Union[_str, 'types.StringFilter']
    outputType: Union[_str, 'types.StringFilter']
    order: Union[_int, 'types.IntFilter']
    timeout: Union[_int, 'types.IntFilter']
    heartbeat: Union[_int, 'types.IntFilter']
    active: Union[_bool, 'types.BooleanFilter']
    description: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    project: 'ProjectRelationFilter'

    # should be noted that AND and NOT should be Union['AssistantWhereInputRecursive2', List['AssistantWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['AssistantWhereInputRecursive2']
    OR: List['AssistantWhereInputRecursive2']
    NOT: List['AssistantWhereInputRecursive2']


class AssistantWhereInputRecursive2(TypedDict, total=False):
    """Assistant arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    projectId: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    functionKey: Union[_str, 'types.StringFilter']
    inputType: Union[_str, 'types.StringFilter']
    outputType: Union[_str, 'types.StringFilter']
    order: Union[_int, 'types.IntFilter']
    timeout: Union[_int, 'types.IntFilter']
    heartbeat: Union[_int, 'types.IntFilter']
    active: Union[_bool, 'types.BooleanFilter']
    description: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    project: 'ProjectRelationFilter'

    # should be noted that AND and NOT should be Union['AssistantWhereInputRecursive3', List['AssistantWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['AssistantWhereInputRecursive3']
    OR: List['AssistantWhereInputRecursive3']
    NOT: List['AssistantWhereInputRecursive3']


class AssistantWhereInputRecursive3(TypedDict, total=False):
    """Assistant arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    projectId: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    functionKey: Union[_str, 'types.StringFilter']
    inputType: Union[_str, 'types.StringFilter']
    outputType: Union[_str, 'types.StringFilter']
    order: Union[_int, 'types.IntFilter']
    timeout: Union[_int, 'types.IntFilter']
    heartbeat: Union[_int, 'types.IntFilter']
    active: Union[_bool, 'types.BooleanFilter']
    description: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    project: 'ProjectRelationFilter'

    # should be noted that AND and NOT should be Union['AssistantWhereInputRecursive4', List['AssistantWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['AssistantWhereInputRecursive4']
    OR: List['AssistantWhereInputRecursive4']
    NOT: List['AssistantWhereInputRecursive4']


class AssistantWhereInputRecursive4(TypedDict, total=False):
    """Assistant arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    projectId: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    functionKey: Union[_str, 'types.StringFilter']
    inputType: Union[_str, 'types.StringFilter']
    outputType: Union[_str, 'types.StringFilter']
    order: Union[_int, 'types.IntFilter']
    timeout: Union[_int, 'types.IntFilter']
    heartbeat: Union[_int, 'types.IntFilter']
    active: Union[_bool, 'types.BooleanFilter']
    description: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    project: 'ProjectRelationFilter'



# aggregate Assistant types


    

class AssistantScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Assistant arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    projectId: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    functionKey: Union[_str, 'types.StringWithAggregatesFilter']
    inputType: Union[_str, 'types.StringWithAggregatesFilter']
    outputType: Union[_str, 'types.StringWithAggregatesFilter']
    order: Union[_int, 'types.IntWithAggregatesFilter']
    timeout: Union[_int, 'types.IntWithAggregatesFilter']
    heartbeat: Union[_int, 'types.IntWithAggregatesFilter']
    active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AssistantScalarWhereWithAggregatesInputRecursive1']
    OR: List['AssistantScalarWhereWithAggregatesInputRecursive1']
    NOT: List['AssistantScalarWhereWithAggregatesInputRecursive1']


class AssistantScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Assistant arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    projectId: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    functionKey: Union[_str, 'types.StringWithAggregatesFilter']
    inputType: Union[_str, 'types.StringWithAggregatesFilter']
    outputType: Union[_str, 'types.StringWithAggregatesFilter']
    order: Union[_int, 'types.IntWithAggregatesFilter']
    timeout: Union[_int, 'types.IntWithAggregatesFilter']
    heartbeat: Union[_int, 'types.IntWithAggregatesFilter']
    active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AssistantScalarWhereWithAggregatesInputRecursive2']
    OR: List['AssistantScalarWhereWithAggregatesInputRecursive2']
    NOT: List['AssistantScalarWhereWithAggregatesInputRecursive2']


class AssistantScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Assistant arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    projectId: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    functionKey: Union[_str, 'types.StringWithAggregatesFilter']
    inputType: Union[_str, 'types.StringWithAggregatesFilter']
    outputType: Union[_str, 'types.StringWithAggregatesFilter']
    order: Union[_int, 'types.IntWithAggregatesFilter']
    timeout: Union[_int, 'types.IntWithAggregatesFilter']
    heartbeat: Union[_int, 'types.IntWithAggregatesFilter']
    active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AssistantScalarWhereWithAggregatesInputRecursive3']
    OR: List['AssistantScalarWhereWithAggregatesInputRecursive3']
    NOT: List['AssistantScalarWhereWithAggregatesInputRecursive3']


class AssistantScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Assistant arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    projectId: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    functionKey: Union[_str, 'types.StringWithAggregatesFilter']
    inputType: Union[_str, 'types.StringWithAggregatesFilter']
    outputType: Union[_str, 'types.StringWithAggregatesFilter']
    order: Union[_int, 'types.IntWithAggregatesFilter']
    timeout: Union[_int, 'types.IntWithAggregatesFilter']
    heartbeat: Union[_int, 'types.IntWithAggregatesFilter']
    active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AssistantScalarWhereWithAggregatesInputRecursive4']
    OR: List['AssistantScalarWhereWithAggregatesInputRecursive4']
    NOT: List['AssistantScalarWhereWithAggregatesInputRecursive4']


class AssistantScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Assistant arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    projectId: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    functionKey: Union[_str, 'types.StringWithAggregatesFilter']
    inputType: Union[_str, 'types.StringWithAggregatesFilter']
    outputType: Union[_str, 'types.StringWithAggregatesFilter']
    order: Union[_int, 'types.IntWithAggregatesFilter']
    timeout: Union[_int, 'types.IntWithAggregatesFilter']
    heartbeat: Union[_int, 'types.IntWithAggregatesFilter']
    active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class AssistantGroupByOutput(TypedDict, total=False):
    id: _str
    projectId: _str
    name: _str
    functionKey: _str
    inputType: _str
    outputType: _str
    order: _int
    timeout: _int
    heartbeat: _int
    active: _bool
    description: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'AssistantSumAggregateOutput'
    _avg: 'AssistantAvgAggregateOutput'
    _min: 'AssistantMinAggregateOutput'
    _max: 'AssistantMaxAggregateOutput'
    _count: 'AssistantCountAggregateOutput'


class AssistantAvgAggregateOutput(TypedDict, total=False):
    """Assistant output for aggregating averages"""
    order: float
    timeout: float
    heartbeat: float


class AssistantSumAggregateOutput(TypedDict, total=False):
    """Assistant output for aggregating sums"""
    order: _int
    timeout: _int
    heartbeat: _int


class AssistantScalarAggregateOutput(TypedDict, total=False):
    """Assistant output including scalar fields"""
    id: _str
    projectId: _str
    name: _str
    functionKey: _str
    inputType: _str
    outputType: _str
    order: _int
    timeout: _int
    heartbeat: _int
    active: _bool
    description: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


AssistantMinAggregateOutput = AssistantScalarAggregateOutput
AssistantMaxAggregateOutput = AssistantScalarAggregateOutput


class AssistantMaxAggregateInput(TypedDict, total=False):
    """Assistant input for aggregating by max"""
    id: bool
    projectId: bool
    name: bool
    functionKey: bool
    inputType: bool
    outputType: bool
    order: bool
    timeout: bool
    heartbeat: bool
    active: bool
    description: bool
    createdAt: bool
    updatedAt: bool


class AssistantMinAggregateInput(TypedDict, total=False):
    """Assistant input for aggregating by min"""
    id: bool
    projectId: bool
    name: bool
    functionKey: bool
    inputType: bool
    outputType: bool
    order: bool
    timeout: bool
    heartbeat: bool
    active: bool
    description: bool
    createdAt: bool
    updatedAt: bool


class AssistantNumberAggregateInput(TypedDict, total=False):
    """Assistant input for aggregating numbers"""
    order: bool
    timeout: bool
    heartbeat: bool


AssistantAvgAggregateInput = AssistantNumberAggregateInput
AssistantSumAggregateInput = AssistantNumberAggregateInput


AssistantCountAggregateInput = TypedDict(
    'AssistantCountAggregateInput',
    {
        'id': bool,
        'projectId': bool,
        'name': bool,
        'functionKey': bool,
        'inputType': bool,
        'outputType': bool,
        'order': bool,
        'timeout': bool,
        'heartbeat': bool,
        'active': bool,
        'description': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

AssistantCountAggregateOutput = TypedDict(
    'AssistantCountAggregateOutput',
    {
        'id': int,
        'projectId': int,
        'name': int,
        'functionKey': int,
        'inputType': int,
        'outputType': int,
        'order': int,
        'timeout': int,
        'heartbeat': int,
        'active': int,
        'description': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


AssistantKeys = Literal[
    'id',
    'projectId',
    'name',
    'functionKey',
    'inputType',
    'outputType',
    'order',
    'timeout',
    'heartbeat',
    'active',
    'description',
    'createdAt',
    'updatedAt',
    'project',
]
AssistantScalarFieldKeys = Literal[
    'id',
    'projectId',
    'name',
    'functionKey',
    'inputType',
    'outputType',
    'order',
    'timeout',
    'heartbeat',
    'active',
    'description',
    'createdAt',
    'updatedAt',
]
AssistantScalarFieldKeysT = TypeVar('AssistantScalarFieldKeysT', bound=AssistantScalarFieldKeys)

AssistantRelationalFieldKeys = Literal[
        'project',
    ]

# WorkflowRun types

class WorkflowRunOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the WorkflowRun create method"""
    id: _str
    projectId: _str
    startedAt: datetime.datetime
    finishedAt: Optional[datetime.datetime]
    outputPath: Optional[_str]
    resultJson: Optional[_str]
    errorMessage: Optional[_str]
    elapsedSeconds: Optional[_int]
    stageCount: Optional[_int]
    totalStages: Optional[_int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    project: 'ProjectCreateNestedWithoutRelationsInput'


class WorkflowRunCreateInput(WorkflowRunOptionalCreateInput):
    """Required arguments to the WorkflowRun create method"""
    runId: _str
    workflowId: _str
    topic: _str
    status: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class WorkflowRunOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the WorkflowRun create method, without relations"""
    id: _str
    projectId: _str
    startedAt: datetime.datetime
    finishedAt: Optional[datetime.datetime]
    outputPath: Optional[_str]
    resultJson: Optional[_str]
    errorMessage: Optional[_str]
    elapsedSeconds: Optional[_int]
    stageCount: Optional[_int]
    totalStages: Optional[_int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class WorkflowRunCreateWithoutRelationsInput(WorkflowRunOptionalCreateWithoutRelationsInput):
    """Required arguments to the WorkflowRun create method, without relations"""
    runId: _str
    workflowId: _str
    topic: _str
    status: _str

class WorkflowRunConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'WorkflowRunCreateWithoutRelationsInput'
    where: 'WorkflowRunWhereUniqueInput'

class WorkflowRunCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'WorkflowRunCreateWithoutRelationsInput'
    connect: 'WorkflowRunWhereUniqueInput'
    connect_or_create: 'WorkflowRunConnectOrCreateWithoutRelationsInput'


class WorkflowRunCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['WorkflowRunCreateWithoutRelationsInput', List['WorkflowRunCreateWithoutRelationsInput']]
    connect: Union['WorkflowRunWhereUniqueInput', List['WorkflowRunWhereUniqueInput']]
    connect_or_create: Union['WorkflowRunConnectOrCreateWithoutRelationsInput', List['WorkflowRunConnectOrCreateWithoutRelationsInput']]

_WorkflowRunWhereUnique_id_Input = TypedDict(
    '_WorkflowRunWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_WorkflowRunCompoundworkflowId_runIdKeyInner = TypedDict(
    '_WorkflowRunCompoundworkflowId_runIdKeyInner',
    {
        'workflowId': '_str',
        'runId': '_str',
    },
    total=True
)

_WorkflowRunCompoundworkflowId_runIdKey = TypedDict(
    '_WorkflowRunCompoundworkflowId_runIdKey',
    {
        'workflowId_runId': '_WorkflowRunCompoundworkflowId_runIdKeyInner',
    },
    total=True
)

WorkflowRunWhereUniqueInput = Union[
    '_WorkflowRunWhereUnique_id_Input',
    '_WorkflowRunCompoundworkflowId_runIdKey',
]


class WorkflowRunUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    runId: _str
    workflowId: _str
    topic: _str
    status: _str
    startedAt: datetime.datetime
    finishedAt: Optional[datetime.datetime]
    outputPath: Optional[_str]
    resultJson: Optional[_str]
    errorMessage: Optional[_str]
    elapsedSeconds: Optional[Union[AtomicIntInput, _int]]
    stageCount: Optional[Union[AtomicIntInput, _int]]
    totalStages: Optional[Union[AtomicIntInput, _int]]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    project: 'ProjectUpdateOneWithoutRelationsInput'


class WorkflowRunUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    runId: _str
    workflowId: _str
    topic: _str
    status: _str
    startedAt: datetime.datetime
    finishedAt: Optional[datetime.datetime]
    outputPath: Optional[_str]
    resultJson: Optional[_str]
    errorMessage: Optional[_str]
    elapsedSeconds: Optional[Union[AtomicIntInput, _int]]
    stageCount: Optional[Union[AtomicIntInput, _int]]
    totalStages: Optional[Union[AtomicIntInput, _int]]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class WorkflowRunUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['WorkflowRunCreateWithoutRelationsInput']
    connect: List['WorkflowRunWhereUniqueInput']
    connect_or_create: List['WorkflowRunConnectOrCreateWithoutRelationsInput']
    set: List['WorkflowRunWhereUniqueInput']
    disconnect: List['WorkflowRunWhereUniqueInput']
    delete: List['WorkflowRunWhereUniqueInput']

    # TODO
    # update: List['WorkflowRunUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['WorkflowRunUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['WorkflowRunScalarWhereInput']
    # upsert: List['WorkflowRunUpserteWithWhereUniqueWithoutRelationsInput']


class WorkflowRunUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'WorkflowRunCreateWithoutRelationsInput'
    connect: 'WorkflowRunWhereUniqueInput'
    connect_or_create: 'WorkflowRunConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'WorkflowRunUpdateInput'
    # upsert: 'WorkflowRunUpsertWithoutRelationsInput'


class WorkflowRunUpsertInput(TypedDict):
    create: 'WorkflowRunCreateInput'
    update: 'WorkflowRunUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_WorkflowRun_id_OrderByInput = TypedDict(
    '_WorkflowRun_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_WorkflowRun_projectId_OrderByInput = TypedDict(
    '_WorkflowRun_projectId_OrderByInput',
    {
        'projectId': 'SortOrder',
    },
    total=True
)

_WorkflowRun_runId_OrderByInput = TypedDict(
    '_WorkflowRun_runId_OrderByInput',
    {
        'runId': 'SortOrder',
    },
    total=True
)

_WorkflowRun_workflowId_OrderByInput = TypedDict(
    '_WorkflowRun_workflowId_OrderByInput',
    {
        'workflowId': 'SortOrder',
    },
    total=True
)

_WorkflowRun_topic_OrderByInput = TypedDict(
    '_WorkflowRun_topic_OrderByInput',
    {
        'topic': 'SortOrder',
    },
    total=True
)

_WorkflowRun_status_OrderByInput = TypedDict(
    '_WorkflowRun_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_WorkflowRun_startedAt_OrderByInput = TypedDict(
    '_WorkflowRun_startedAt_OrderByInput',
    {
        'startedAt': 'SortOrder',
    },
    total=True
)

_WorkflowRun_finishedAt_OrderByInput = TypedDict(
    '_WorkflowRun_finishedAt_OrderByInput',
    {
        'finishedAt': 'SortOrder',
    },
    total=True
)

_WorkflowRun_outputPath_OrderByInput = TypedDict(
    '_WorkflowRun_outputPath_OrderByInput',
    {
        'outputPath': 'SortOrder',
    },
    total=True
)

_WorkflowRun_resultJson_OrderByInput = TypedDict(
    '_WorkflowRun_resultJson_OrderByInput',
    {
        'resultJson': 'SortOrder',
    },
    total=True
)

_WorkflowRun_errorMessage_OrderByInput = TypedDict(
    '_WorkflowRun_errorMessage_OrderByInput',
    {
        'errorMessage': 'SortOrder',
    },
    total=True
)

_WorkflowRun_elapsedSeconds_OrderByInput = TypedDict(
    '_WorkflowRun_elapsedSeconds_OrderByInput',
    {
        'elapsedSeconds': 'SortOrder',
    },
    total=True
)

_WorkflowRun_stageCount_OrderByInput = TypedDict(
    '_WorkflowRun_stageCount_OrderByInput',
    {
        'stageCount': 'SortOrder',
    },
    total=True
)

_WorkflowRun_totalStages_OrderByInput = TypedDict(
    '_WorkflowRun_totalStages_OrderByInput',
    {
        'totalStages': 'SortOrder',
    },
    total=True
)

_WorkflowRun_createdAt_OrderByInput = TypedDict(
    '_WorkflowRun_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_WorkflowRun_updatedAt_OrderByInput = TypedDict(
    '_WorkflowRun_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

WorkflowRunOrderByInput = Union[
    '_WorkflowRun_id_OrderByInput',
    '_WorkflowRun_projectId_OrderByInput',
    '_WorkflowRun_runId_OrderByInput',
    '_WorkflowRun_workflowId_OrderByInput',
    '_WorkflowRun_topic_OrderByInput',
    '_WorkflowRun_status_OrderByInput',
    '_WorkflowRun_startedAt_OrderByInput',
    '_WorkflowRun_finishedAt_OrderByInput',
    '_WorkflowRun_outputPath_OrderByInput',
    '_WorkflowRun_resultJson_OrderByInput',
    '_WorkflowRun_errorMessage_OrderByInput',
    '_WorkflowRun_elapsedSeconds_OrderByInput',
    '_WorkflowRun_stageCount_OrderByInput',
    '_WorkflowRun_totalStages_OrderByInput',
    '_WorkflowRun_createdAt_OrderByInput',
    '_WorkflowRun_updatedAt_OrderByInput',
]



# recursive WorkflowRun types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

WorkflowRunRelationFilter = TypedDict(
    'WorkflowRunRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class WorkflowRunListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class WorkflowRunInclude(TypedDict, total=False):
    """WorkflowRun relational arguments"""
    project: Union[bool, 'ProjectArgsFromWorkflowRun']


    

class ProjectIncludeFromWorkflowRun(TypedDict, total=False):
    """Relational arguments for WorkflowRun"""
    assistants: Union[bool, 'FindManyAssistantArgsFromWorkflowRunRecursive1']
    workflowRuns: Union[bool, 'FindManyWorkflowRunArgsFromWorkflowRunRecursive1']


class ProjectIncludeFromWorkflowRunRecursive1(TypedDict, total=False):
    """Relational arguments for WorkflowRun"""
    assistants: Union[bool, 'FindManyAssistantArgsFromWorkflowRunRecursive2']
    workflowRuns: Union[bool, 'FindManyWorkflowRunArgsFromWorkflowRunRecursive2']


class ProjectIncludeFromWorkflowRunRecursive2(TypedDict, total=False):
    """Relational arguments for WorkflowRun"""
    assistants: Union[bool, 'FindManyAssistantArgsFromWorkflowRunRecursive3']
    workflowRuns: Union[bool, 'FindManyWorkflowRunArgsFromWorkflowRunRecursive3']


class ProjectIncludeFromWorkflowRunRecursive3(TypedDict, total=False):
    """Relational arguments for WorkflowRun"""
    assistants: Union[bool, 'FindManyAssistantArgsFromWorkflowRunRecursive4']
    workflowRuns: Union[bool, 'FindManyWorkflowRunArgsFromWorkflowRunRecursive4']


class ProjectIncludeFromWorkflowRunRecursive4(TypedDict, total=False):
    """Relational arguments for WorkflowRun"""

    

class ProjectArgsFromWorkflowRun(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    include: 'ProjectIncludeFromProjectRecursive1'


class ProjectArgsFromWorkflowRunRecursive1(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    include: 'ProjectIncludeFromProjectRecursive2'


class ProjectArgsFromWorkflowRunRecursive2(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    include: 'ProjectIncludeFromProjectRecursive3'


class ProjectArgsFromWorkflowRunRecursive3(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    include: 'ProjectIncludeFromProjectRecursive4'


class ProjectArgsFromWorkflowRunRecursive4(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    
    

class FindManyProjectArgsFromWorkflowRun(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive1'


class FindManyProjectArgsFromWorkflowRunRecursive1(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive2'


class FindManyProjectArgsFromWorkflowRunRecursive2(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive3'


class FindManyProjectArgsFromWorkflowRunRecursive3(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProjectRecursive4'


class FindManyProjectArgsFromWorkflowRunRecursive4(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    
    

class AssistantIncludeFromWorkflowRun(TypedDict, total=False):
    """Relational arguments for WorkflowRun"""
    project: Union[bool, 'ProjectArgsFromWorkflowRunRecursive1']


class AssistantIncludeFromWorkflowRunRecursive1(TypedDict, total=False):
    """Relational arguments for WorkflowRun"""
    project: Union[bool, 'ProjectArgsFromWorkflowRunRecursive2']


class AssistantIncludeFromWorkflowRunRecursive2(TypedDict, total=False):
    """Relational arguments for WorkflowRun"""
    project: Union[bool, 'ProjectArgsFromWorkflowRunRecursive3']


class AssistantIncludeFromWorkflowRunRecursive3(TypedDict, total=False):
    """Relational arguments for WorkflowRun"""
    project: Union[bool, 'ProjectArgsFromWorkflowRunRecursive4']


class AssistantIncludeFromWorkflowRunRecursive4(TypedDict, total=False):
    """Relational arguments for WorkflowRun"""

    

class AssistantArgsFromWorkflowRun(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    include: 'AssistantIncludeFromAssistantRecursive1'


class AssistantArgsFromWorkflowRunRecursive1(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    include: 'AssistantIncludeFromAssistantRecursive2'


class AssistantArgsFromWorkflowRunRecursive2(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    include: 'AssistantIncludeFromAssistantRecursive3'


class AssistantArgsFromWorkflowRunRecursive3(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    include: 'AssistantIncludeFromAssistantRecursive4'


class AssistantArgsFromWorkflowRunRecursive4(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    
    

class FindManyAssistantArgsFromWorkflowRun(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    take: int
    skip: int
    order_by: Union['AssistantOrderByInput', List['AssistantOrderByInput']]
    where: 'AssistantWhereInput'
    cursor: 'AssistantWhereUniqueInput'
    distinct: List['AssistantScalarFieldKeys']
    include: 'AssistantIncludeFromAssistantRecursive1'


class FindManyAssistantArgsFromWorkflowRunRecursive1(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    take: int
    skip: int
    order_by: Union['AssistantOrderByInput', List['AssistantOrderByInput']]
    where: 'AssistantWhereInput'
    cursor: 'AssistantWhereUniqueInput'
    distinct: List['AssistantScalarFieldKeys']
    include: 'AssistantIncludeFromAssistantRecursive2'


class FindManyAssistantArgsFromWorkflowRunRecursive2(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    take: int
    skip: int
    order_by: Union['AssistantOrderByInput', List['AssistantOrderByInput']]
    where: 'AssistantWhereInput'
    cursor: 'AssistantWhereUniqueInput'
    distinct: List['AssistantScalarFieldKeys']
    include: 'AssistantIncludeFromAssistantRecursive3'


class FindManyAssistantArgsFromWorkflowRunRecursive3(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    take: int
    skip: int
    order_by: Union['AssistantOrderByInput', List['AssistantOrderByInput']]
    where: 'AssistantWhereInput'
    cursor: 'AssistantWhereUniqueInput'
    distinct: List['AssistantScalarFieldKeys']
    include: 'AssistantIncludeFromAssistantRecursive4'


class FindManyAssistantArgsFromWorkflowRunRecursive4(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    take: int
    skip: int
    order_by: Union['AssistantOrderByInput', List['AssistantOrderByInput']]
    where: 'AssistantWhereInput'
    cursor: 'AssistantWhereUniqueInput'
    distinct: List['AssistantScalarFieldKeys']
    
    

class WorkflowRunIncludeFromWorkflowRun(TypedDict, total=False):
    """Relational arguments for WorkflowRun"""
    project: Union[bool, 'ProjectArgsFromWorkflowRunRecursive1']


class WorkflowRunIncludeFromWorkflowRunRecursive1(TypedDict, total=False):
    """Relational arguments for WorkflowRun"""
    project: Union[bool, 'ProjectArgsFromWorkflowRunRecursive2']


class WorkflowRunIncludeFromWorkflowRunRecursive2(TypedDict, total=False):
    """Relational arguments for WorkflowRun"""
    project: Union[bool, 'ProjectArgsFromWorkflowRunRecursive3']


class WorkflowRunIncludeFromWorkflowRunRecursive3(TypedDict, total=False):
    """Relational arguments for WorkflowRun"""
    project: Union[bool, 'ProjectArgsFromWorkflowRunRecursive4']


class WorkflowRunIncludeFromWorkflowRunRecursive4(TypedDict, total=False):
    """Relational arguments for WorkflowRun"""

    

class WorkflowRunArgsFromWorkflowRun(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive1'


class WorkflowRunArgsFromWorkflowRunRecursive1(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive2'


class WorkflowRunArgsFromWorkflowRunRecursive2(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive3'


class WorkflowRunArgsFromWorkflowRunRecursive3(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive4'


class WorkflowRunArgsFromWorkflowRunRecursive4(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    
    

class FindManyWorkflowRunArgsFromWorkflowRun(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    take: int
    skip: int
    order_by: Union['WorkflowRunOrderByInput', List['WorkflowRunOrderByInput']]
    where: 'WorkflowRunWhereInput'
    cursor: 'WorkflowRunWhereUniqueInput'
    distinct: List['WorkflowRunScalarFieldKeys']
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive1'


class FindManyWorkflowRunArgsFromWorkflowRunRecursive1(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    take: int
    skip: int
    order_by: Union['WorkflowRunOrderByInput', List['WorkflowRunOrderByInput']]
    where: 'WorkflowRunWhereInput'
    cursor: 'WorkflowRunWhereUniqueInput'
    distinct: List['WorkflowRunScalarFieldKeys']
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive2'


class FindManyWorkflowRunArgsFromWorkflowRunRecursive2(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    take: int
    skip: int
    order_by: Union['WorkflowRunOrderByInput', List['WorkflowRunOrderByInput']]
    where: 'WorkflowRunWhereInput'
    cursor: 'WorkflowRunWhereUniqueInput'
    distinct: List['WorkflowRunScalarFieldKeys']
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive3'


class FindManyWorkflowRunArgsFromWorkflowRunRecursive3(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    take: int
    skip: int
    order_by: Union['WorkflowRunOrderByInput', List['WorkflowRunOrderByInput']]
    where: 'WorkflowRunWhereInput'
    cursor: 'WorkflowRunWhereUniqueInput'
    distinct: List['WorkflowRunScalarFieldKeys']
    include: 'WorkflowRunIncludeFromWorkflowRunRecursive4'


class FindManyWorkflowRunArgsFromWorkflowRunRecursive4(TypedDict, total=False):
    """Arguments for WorkflowRun"""
    take: int
    skip: int
    order_by: Union['WorkflowRunOrderByInput', List['WorkflowRunOrderByInput']]
    where: 'WorkflowRunWhereInput'
    cursor: 'WorkflowRunWhereUniqueInput'
    distinct: List['WorkflowRunScalarFieldKeys']
    


FindManyWorkflowRunArgs = FindManyWorkflowRunArgsFromWorkflowRun
FindFirstWorkflowRunArgs = FindManyWorkflowRunArgsFromWorkflowRun


    

class WorkflowRunWhereInput(TypedDict, total=False):
    """WorkflowRun arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    projectId: Union[_str, 'types.StringFilter']
    runId: Union[_str, 'types.StringFilter']
    workflowId: Union[_str, 'types.StringFilter']
    topic: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    startedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    finishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    outputPath: Union[None, _str, 'types.StringFilter']
    resultJson: Union[None, _str, 'types.StringFilter']
    errorMessage: Union[None, _str, 'types.StringFilter']
    elapsedSeconds: Union[None, _int, 'types.IntFilter']
    stageCount: Union[None, _int, 'types.IntFilter']
    totalStages: Union[None, _int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    project: 'ProjectRelationFilter'

    # should be noted that AND and NOT should be Union['WorkflowRunWhereInputRecursive1', List['WorkflowRunWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['WorkflowRunWhereInputRecursive1']
    OR: List['WorkflowRunWhereInputRecursive1']
    NOT: List['WorkflowRunWhereInputRecursive1']


class WorkflowRunWhereInputRecursive1(TypedDict, total=False):
    """WorkflowRun arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    projectId: Union[_str, 'types.StringFilter']
    runId: Union[_str, 'types.StringFilter']
    workflowId: Union[_str, 'types.StringFilter']
    topic: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    startedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    finishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    outputPath: Union[None, _str, 'types.StringFilter']
    resultJson: Union[None, _str, 'types.StringFilter']
    errorMessage: Union[None, _str, 'types.StringFilter']
    elapsedSeconds: Union[None, _int, 'types.IntFilter']
    stageCount: Union[None, _int, 'types.IntFilter']
    totalStages: Union[None, _int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    project: 'ProjectRelationFilter'

    # should be noted that AND and NOT should be Union['WorkflowRunWhereInputRecursive2', List['WorkflowRunWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['WorkflowRunWhereInputRecursive2']
    OR: List['WorkflowRunWhereInputRecursive2']
    NOT: List['WorkflowRunWhereInputRecursive2']


class WorkflowRunWhereInputRecursive2(TypedDict, total=False):
    """WorkflowRun arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    projectId: Union[_str, 'types.StringFilter']
    runId: Union[_str, 'types.StringFilter']
    workflowId: Union[_str, 'types.StringFilter']
    topic: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    startedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    finishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    outputPath: Union[None, _str, 'types.StringFilter']
    resultJson: Union[None, _str, 'types.StringFilter']
    errorMessage: Union[None, _str, 'types.StringFilter']
    elapsedSeconds: Union[None, _int, 'types.IntFilter']
    stageCount: Union[None, _int, 'types.IntFilter']
    totalStages: Union[None, _int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    project: 'ProjectRelationFilter'

    # should be noted that AND and NOT should be Union['WorkflowRunWhereInputRecursive3', List['WorkflowRunWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['WorkflowRunWhereInputRecursive3']
    OR: List['WorkflowRunWhereInputRecursive3']
    NOT: List['WorkflowRunWhereInputRecursive3']


class WorkflowRunWhereInputRecursive3(TypedDict, total=False):
    """WorkflowRun arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    projectId: Union[_str, 'types.StringFilter']
    runId: Union[_str, 'types.StringFilter']
    workflowId: Union[_str, 'types.StringFilter']
    topic: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    startedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    finishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    outputPath: Union[None, _str, 'types.StringFilter']
    resultJson: Union[None, _str, 'types.StringFilter']
    errorMessage: Union[None, _str, 'types.StringFilter']
    elapsedSeconds: Union[None, _int, 'types.IntFilter']
    stageCount: Union[None, _int, 'types.IntFilter']
    totalStages: Union[None, _int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    project: 'ProjectRelationFilter'

    # should be noted that AND and NOT should be Union['WorkflowRunWhereInputRecursive4', List['WorkflowRunWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['WorkflowRunWhereInputRecursive4']
    OR: List['WorkflowRunWhereInputRecursive4']
    NOT: List['WorkflowRunWhereInputRecursive4']


class WorkflowRunWhereInputRecursive4(TypedDict, total=False):
    """WorkflowRun arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    projectId: Union[_str, 'types.StringFilter']
    runId: Union[_str, 'types.StringFilter']
    workflowId: Union[_str, 'types.StringFilter']
    topic: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    startedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    finishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    outputPath: Union[None, _str, 'types.StringFilter']
    resultJson: Union[None, _str, 'types.StringFilter']
    errorMessage: Union[None, _str, 'types.StringFilter']
    elapsedSeconds: Union[None, _int, 'types.IntFilter']
    stageCount: Union[None, _int, 'types.IntFilter']
    totalStages: Union[None, _int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    project: 'ProjectRelationFilter'



# aggregate WorkflowRun types


    

class WorkflowRunScalarWhereWithAggregatesInput(TypedDict, total=False):
    """WorkflowRun arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    projectId: Union[_str, 'types.StringWithAggregatesFilter']
    runId: Union[_str, 'types.StringWithAggregatesFilter']
    workflowId: Union[_str, 'types.StringWithAggregatesFilter']
    topic: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    startedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    finishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    outputPath: Union[_str, 'types.StringWithAggregatesFilter']
    resultJson: Union[_str, 'types.StringWithAggregatesFilter']
    errorMessage: Union[_str, 'types.StringWithAggregatesFilter']
    elapsedSeconds: Union[_int, 'types.IntWithAggregatesFilter']
    stageCount: Union[_int, 'types.IntWithAggregatesFilter']
    totalStages: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['WorkflowRunScalarWhereWithAggregatesInputRecursive1']
    OR: List['WorkflowRunScalarWhereWithAggregatesInputRecursive1']
    NOT: List['WorkflowRunScalarWhereWithAggregatesInputRecursive1']


class WorkflowRunScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """WorkflowRun arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    projectId: Union[_str, 'types.StringWithAggregatesFilter']
    runId: Union[_str, 'types.StringWithAggregatesFilter']
    workflowId: Union[_str, 'types.StringWithAggregatesFilter']
    topic: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    startedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    finishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    outputPath: Union[_str, 'types.StringWithAggregatesFilter']
    resultJson: Union[_str, 'types.StringWithAggregatesFilter']
    errorMessage: Union[_str, 'types.StringWithAggregatesFilter']
    elapsedSeconds: Union[_int, 'types.IntWithAggregatesFilter']
    stageCount: Union[_int, 'types.IntWithAggregatesFilter']
    totalStages: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['WorkflowRunScalarWhereWithAggregatesInputRecursive2']
    OR: List['WorkflowRunScalarWhereWithAggregatesInputRecursive2']
    NOT: List['WorkflowRunScalarWhereWithAggregatesInputRecursive2']


class WorkflowRunScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """WorkflowRun arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    projectId: Union[_str, 'types.StringWithAggregatesFilter']
    runId: Union[_str, 'types.StringWithAggregatesFilter']
    workflowId: Union[_str, 'types.StringWithAggregatesFilter']
    topic: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    startedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    finishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    outputPath: Union[_str, 'types.StringWithAggregatesFilter']
    resultJson: Union[_str, 'types.StringWithAggregatesFilter']
    errorMessage: Union[_str, 'types.StringWithAggregatesFilter']
    elapsedSeconds: Union[_int, 'types.IntWithAggregatesFilter']
    stageCount: Union[_int, 'types.IntWithAggregatesFilter']
    totalStages: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['WorkflowRunScalarWhereWithAggregatesInputRecursive3']
    OR: List['WorkflowRunScalarWhereWithAggregatesInputRecursive3']
    NOT: List['WorkflowRunScalarWhereWithAggregatesInputRecursive3']


class WorkflowRunScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """WorkflowRun arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    projectId: Union[_str, 'types.StringWithAggregatesFilter']
    runId: Union[_str, 'types.StringWithAggregatesFilter']
    workflowId: Union[_str, 'types.StringWithAggregatesFilter']
    topic: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    startedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    finishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    outputPath: Union[_str, 'types.StringWithAggregatesFilter']
    resultJson: Union[_str, 'types.StringWithAggregatesFilter']
    errorMessage: Union[_str, 'types.StringWithAggregatesFilter']
    elapsedSeconds: Union[_int, 'types.IntWithAggregatesFilter']
    stageCount: Union[_int, 'types.IntWithAggregatesFilter']
    totalStages: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['WorkflowRunScalarWhereWithAggregatesInputRecursive4']
    OR: List['WorkflowRunScalarWhereWithAggregatesInputRecursive4']
    NOT: List['WorkflowRunScalarWhereWithAggregatesInputRecursive4']


class WorkflowRunScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """WorkflowRun arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    projectId: Union[_str, 'types.StringWithAggregatesFilter']
    runId: Union[_str, 'types.StringWithAggregatesFilter']
    workflowId: Union[_str, 'types.StringWithAggregatesFilter']
    topic: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    startedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    finishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    outputPath: Union[_str, 'types.StringWithAggregatesFilter']
    resultJson: Union[_str, 'types.StringWithAggregatesFilter']
    errorMessage: Union[_str, 'types.StringWithAggregatesFilter']
    elapsedSeconds: Union[_int, 'types.IntWithAggregatesFilter']
    stageCount: Union[_int, 'types.IntWithAggregatesFilter']
    totalStages: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class WorkflowRunGroupByOutput(TypedDict, total=False):
    id: _str
    projectId: _str
    runId: _str
    workflowId: _str
    topic: _str
    status: _str
    startedAt: datetime.datetime
    finishedAt: datetime.datetime
    outputPath: _str
    resultJson: _str
    errorMessage: _str
    elapsedSeconds: _int
    stageCount: _int
    totalStages: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'WorkflowRunSumAggregateOutput'
    _avg: 'WorkflowRunAvgAggregateOutput'
    _min: 'WorkflowRunMinAggregateOutput'
    _max: 'WorkflowRunMaxAggregateOutput'
    _count: 'WorkflowRunCountAggregateOutput'


class WorkflowRunAvgAggregateOutput(TypedDict, total=False):
    """WorkflowRun output for aggregating averages"""
    elapsedSeconds: float
    stageCount: float
    totalStages: float


class WorkflowRunSumAggregateOutput(TypedDict, total=False):
    """WorkflowRun output for aggregating sums"""
    elapsedSeconds: _int
    stageCount: _int
    totalStages: _int


class WorkflowRunScalarAggregateOutput(TypedDict, total=False):
    """WorkflowRun output including scalar fields"""
    id: _str
    projectId: _str
    runId: _str
    workflowId: _str
    topic: _str
    status: _str
    startedAt: datetime.datetime
    finishedAt: datetime.datetime
    outputPath: _str
    resultJson: _str
    errorMessage: _str
    elapsedSeconds: _int
    stageCount: _int
    totalStages: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


WorkflowRunMinAggregateOutput = WorkflowRunScalarAggregateOutput
WorkflowRunMaxAggregateOutput = WorkflowRunScalarAggregateOutput


class WorkflowRunMaxAggregateInput(TypedDict, total=False):
    """WorkflowRun input for aggregating by max"""
    id: bool
    projectId: bool
    runId: bool
    workflowId: bool
    topic: bool
    status: bool
    startedAt: bool
    finishedAt: bool
    outputPath: bool
    resultJson: bool
    errorMessage: bool
    elapsedSeconds: bool
    stageCount: bool
    totalStages: bool
    createdAt: bool
    updatedAt: bool


class WorkflowRunMinAggregateInput(TypedDict, total=False):
    """WorkflowRun input for aggregating by min"""
    id: bool
    projectId: bool
    runId: bool
    workflowId: bool
    topic: bool
    status: bool
    startedAt: bool
    finishedAt: bool
    outputPath: bool
    resultJson: bool
    errorMessage: bool
    elapsedSeconds: bool
    stageCount: bool
    totalStages: bool
    createdAt: bool
    updatedAt: bool


class WorkflowRunNumberAggregateInput(TypedDict, total=False):
    """WorkflowRun input for aggregating numbers"""
    elapsedSeconds: bool
    stageCount: bool
    totalStages: bool


WorkflowRunAvgAggregateInput = WorkflowRunNumberAggregateInput
WorkflowRunSumAggregateInput = WorkflowRunNumberAggregateInput


WorkflowRunCountAggregateInput = TypedDict(
    'WorkflowRunCountAggregateInput',
    {
        'id': bool,
        'projectId': bool,
        'runId': bool,
        'workflowId': bool,
        'topic': bool,
        'status': bool,
        'startedAt': bool,
        'finishedAt': bool,
        'outputPath': bool,
        'resultJson': bool,
        'errorMessage': bool,
        'elapsedSeconds': bool,
        'stageCount': bool,
        'totalStages': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

WorkflowRunCountAggregateOutput = TypedDict(
    'WorkflowRunCountAggregateOutput',
    {
        'id': int,
        'projectId': int,
        'runId': int,
        'workflowId': int,
        'topic': int,
        'status': int,
        'startedAt': int,
        'finishedAt': int,
        'outputPath': int,
        'resultJson': int,
        'errorMessage': int,
        'elapsedSeconds': int,
        'stageCount': int,
        'totalStages': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


WorkflowRunKeys = Literal[
    'id',
    'projectId',
    'runId',
    'workflowId',
    'topic',
    'status',
    'startedAt',
    'finishedAt',
    'outputPath',
    'resultJson',
    'errorMessage',
    'elapsedSeconds',
    'stageCount',
    'totalStages',
    'createdAt',
    'updatedAt',
    'project',
]
WorkflowRunScalarFieldKeys = Literal[
    'id',
    'projectId',
    'runId',
    'workflowId',
    'topic',
    'status',
    'startedAt',
    'finishedAt',
    'outputPath',
    'resultJson',
    'errorMessage',
    'elapsedSeconds',
    'stageCount',
    'totalStages',
    'createdAt',
    'updatedAt',
]
WorkflowRunScalarFieldKeysT = TypeVar('WorkflowRunScalarFieldKeysT', bound=WorkflowRunScalarFieldKeys)

WorkflowRunRelationalFieldKeys = Literal[
        'project',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields